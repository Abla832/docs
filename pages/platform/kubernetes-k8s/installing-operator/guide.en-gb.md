---
title: Deploy an Operator based on Helm on OVHcloud managed Kubernetes
slug: installing-operator
excerpt: Learn how to deploy operator on OVHcloud managed Kubernetes with Helm and the Operator SDK
section: Tutorials
---

**Last updated 21th February, 2022.**

<style>
 pre {
     font-size: 14px;
 }
 pre.console {
   background-color: #300A24; 
   color: #ccc;
   font-family: monospace;
   padding: 5px;
   margin-bottom: 5px;
 }
 pre.console code {
   border: solid 0px transparent;
   font-family: monospace !important;
   font-size: 0.75em;
   color: #ccc;
 }
 .small {
     font-size: 0.75em;
 }
</style>

## Objective

[Operators](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/) are a way to extend Kubernetes to automate some actions in the cluster.

![Operator diagram](images/operator.png)

In few words an operator offers OPS actions programmatically and avoid repetitive human activities that are devoid of lasting value.
The tasks that an operator can do are various and can be on resources deployed in Kubernetes (like a POD for example) or outside (like a database for example).
In our examples we focused on resources inside a Kubernetes cluster.

An operator is based on a [Custom Resource](https://kubernetes.io/docs/concepts/extend-kubernetes/api-extension/custom-resources/) that allows extend Kubernetes API.
Thanks to the control loop of Kubernetes the operator maintain the right state of the resources.
Next the job of the operator is to maintain the state of the internal or external objects that it manages.

There several capabilities for an operator:

* basic installation and configuration of an application,
* upgrade the application (with rollback if needed),
* backup and restore if the operator manages a state,
* auto-remediation of the application if a problem occurs,
* monitoring and observability for its own metrics,
* auto scaling, auto tuning, ...  

A good resume of the capabilities of an operator can be found on the [operator framework website](https://operatorframework.io/operator-capabilities/).

As an operator is a custom API in Kubernetes you have to develop it, fortunately there are frameworks to help you to develop your own operator.
The most important [framework](https://operatorframework.io/operator-capabilities/) allows you to develop an operator with Ansible, Helm and Go.
Another kind of frameworks exist to use another languages, like Java for instance with the [Java operator SDK](https://github.com/java-operator-sdk/java-operator-sdk).

As we can see with the below tutorial, the capability of the developed operator depends of the language, for example develop an operator with Helm offers less capabilities (but it's simpler).

## Requirements

This tutorial presupposes that you already have a working OVHcloud managed Kubernetes cluster, and some basic knowledge of how to operate it. If you want to know more on those topics, please look at the [deploying a Hello World application](../deploying-hello-world/) documentation.

## Instructions

In his tutorial, we create a simple operator that manages the installation of an Nginx server and monitors it.  
Our operator will allow us to:
 - install an Ngnix server with the required number of PODs,
 - upgrade the number of PODs,
 - change the HTTP port,
 - recreate the service if it is deleted.

We'll develop this operator with the [operator SDK](https://sdk.operatorframework.io) with the Helm option.
We'll see in another articles how develop operators with other languages (Go for example).

### Install the CLI

The SDK comes with a [CLI](https://sdk.operatorframework.io/docs/cli/) (**C**ommand **L**ine **I**nterface).
Let install it !

In this case we use [homebrew](https://brew.sh/) but a lot of [other ways](https://sdk.operatorframework.io/docs/installation/) are available.

```bash
brew install operator-sdk
```

Let's test it !
```bash
❯ operator-sdk version

operator-sdk version: "v1.17.0", commit: "704b02a9ba86e85f43edb1b20457859e9eedc6e6", kubernetes version: "v1.21", go version: "go1.17.6", GOOS: "darwin", GOARCH: "arm64"
```
### Develop an operator with Helm
For ou first development we'll use [Helm](https://helm.sh/).
Helm is a package manager and providing templates to deploy applications in Kubernetes.

The CLI offers to scaffold an entire project.
We don't use the scaffolding for this tutorial because it generates a lot of files.
This is useful for a comprehensive and professional operator but would make harder the comprehension of our _hello world_.

More information on the project layout generated by the CLI is available in the [official documentation](https://sdk.operatorframework.io/docs/overview/project-layout/).

#### The helm chart
An operator based on helm is nothing more a classic helm chart !
Let's see our simple helm chart to deploy a Nginx server.

The _deployment.yaml_ template:
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: {{ include "ovh-nginx.fullname" . }}
  labels:
    {{- include "ovh-nginx.labels" . | nindent 4 }}
spec:
  replicas: {{ .Values.replicaCount }} # Thanks to Helm the replica field will be dynamic
  selector:
    matchLabels:
      {{- include "ovh-nginx.selectorLabels" . | nindent 6 }}
  template:
    metadata:
      labels:
        {{- include "ovh-nginx.selectorLabels" . | nindent 8 }}
    spec:
      containers:
        - name: {{ .Chart.Name }}
          image: "{{ .Values.image.repository }}:{{ .Values.image.tag | default .Chart.AppVersion }}"
          imagePullPolicy: {{ .Values.image.pullPolicy }}
          resources:
            requests:
              memory: "2Mi"
              cpu: "0"
            limits:
              memory: "32Mi"
              cpu: "500m"          
          ports:
            - name: http
              containerPort: 80
              protocol: TCP
          livenessProbe:
            httpGet:
              path: /
              port: http
          readinessProbe:
            httpGet:
              path: /
              port: http
```
The _service.yaml_ template:
```yaml
apiVersion: v1
kind: Service
metadata:
  name: {{ include "ovh-nginx.fullname" . }}
  labels:
    {{- include "ovh-nginx.labels" . | nindent 4 }}
spec:
  type: {{ .Values.service.type }}
  ports:
    - port: {{ .Values.service.port }} # Thanks to Helm the HTTP port field will be dynamic
      targetPort: http
      protocol: TCP
      name: http
  selector:
    {{- include "ovh-nginx.selectorLabels" . | nindent 4 }}
```

The _values.yaml_ file:
```yaml
# To allow our operator to change the number of replicas
replicaCount: 1

image:
  repository: ovhplatform/hello
  pullPolicy: IfNotPresent
  tag: "1.0"

service:
  type: LoadBalancer
  # To allow our operator to change the port
  port: 80
```
> [!info]
>
> Only fields in values.yaml file can be managed by the operator.
>

A little helper to simplify the templates (__helper.tpl_):
```
{{/*
Expand the name of the chart.
*/}}
{{- define "ovh-nginx.name" -}}
{{- default .Chart.Name | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Create a default fully qualified app name.
We truncate at 63 chars because some Kubernetes name fields are limited to this (by the DNS naming spec).
If release name contains chart name it will be used as a full name.
*/}}
{{- define "ovh-nginx.fullname" -}}
{{- printf "%s-%s" .Release.Name .Chart.Name | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Create chart name and version as used by the chart label.
*/}}
{{- define "ovh-nginx.chart" -}}
{{- printf "%s-%s" .Chart.Name .Chart.Version | replace "+" "_" | trunc 63 | trimSuffix "-" }}
{{- end }}

{{/*
Common labels
*/}}
{{- define "ovh-nginx.labels" -}}
helm.sh/chart: {{ include "ovh-nginx.chart" . }}
{{ include "ovh-nginx.selectorLabels" . }}
{{- if .Chart.AppVersion }}
app.kubernetes.io/version: {{ .Chart.AppVersion | quote }}
{{- end }}
app.kubernetes.io/managed-by: {{ .Release.Service }}
{{- end }}

{{/*
Selector labels
*/}}
{{- define "ovh-nginx.selectorLabels" -}}
app.kubernetes.io/name: {{ include "ovh-nginx.name" . }}
app.kubernetes.io/instance: {{ .Release.Name }}
{{- end }}
```

And to finish the _chart.yaml_ file:
```yaml
apiVersion: v2
appVersion: 1.0
description: A Helm chart to deploy the OVHcloud hello world Nginx server
name: ovh-nginx
type: application
version: 0.1.0
```
Put all files in the following tree structure:
```bash
tree
.
├── helm-charts
│   └── ovh-nginx
│       ├── Chart.yaml
│       ├── templates
│       │   ├── _helpers.tpl
│       │   ├── deployment.yaml
│       │   └── service.yaml
│       └── values.yaml
```

At this point we have only created a classic helm chart.
We can use it with the helm client to deploy the Nginx server but in the following sections we'll see how to delegate this to an operator.

### The custom resource definition
The [custom resources definition](https://kubernetes.io/docs/tasks/extend-kubernetes/custom-resources/custom-resource-definitions/) (CRDs) is the main point of the operator.
It allows us to extend the default API of Kubernertes.
Let's have a look to our CRD (`tutorials.ovhcloud.com_ovhnginxoperators.yaml`):
```yaml
apiVersion: apiextensions.k8s.io/v1
kind: CustomResourceDefinition # The API to declare new API (CRD)
metadata:
  name: ovhnginxs.tutorials.ovhcloud.com
spec:
  group: tutorials.ovhcloud.com
  names:
    kind: OvhNginx  # The name of our CRD 
    listKind: OvhNginxList
    plural: ovhnginxs
    singular: ovhnginx # To get the created CR with kubectl
  scope: Namespaced
  versions:
  - name: v1
    schema:
      openAPIV3Schema:
        type: object
        properties:
          spec: # List of the properties in the CR, must match the values.yaml structure
            type: object
            properties:
              service:
                type: object
                properties:
                  port:  # To change the port of the Nginx server
                    type: integer
              replicaCount:  # To change the number of POD
                type: integer
    served: true
    storage: true
    subresources:
      status: {}
```

With the CRD we create a _watches.yaml_ file that indicates to the Operator which helm chart and CRD use:
```yaml
- group: tutorials.ovhcloud.com
  version: v1
  kind: OvhNginx
  chart: helm-charts/ovh-nginx
```
Put all the files in the following tree structure:
```bash
tree
.
├── helm-charts
│   └── ovh-nginx
│       ├── Chart.yaml
│       ├── templates
│       │   ├── _helpers.tpl
│       │   ├── deployment.yaml
│       │   └── service.yaml
│       └── values.yaml
├── manifests
│   ├── crd
│   │   └── tutorials.ovhcloud.com_ovhnginxoperators.yaml
└── watches.yaml
```

### Test it locally (almost)

Before packaging and deploying our operator in a real Kubernetes cluster we can test it locally.
You still need a Kubernetes cluster to deploy your CRD and the Nginx server managed by the operator.
First, create the CRD in your Kubernetes cluster:
```bash
❯ kubectl apply -f manifests/crd/tutorials.ovhcloud.com_ovhnginxoperators.yaml
customresourcedefinition.apiextensions.k8s.io/ovhnginxs.tutorials.ovhcloud.com created

❯ kubectl get crds/ovhnginxs.tutorials.ovhcloud.com
NAME                               CREATED AT
ovhnginxs.tutorials.ovhcloud.com   2022-02-18T13:51:14Z
```

At this point it is not necessary to deploy the operator in the Kubernetes cluster, you can run it locally on your computer:
```bash
❯ helm-operator run

{"level":"info","ts":1645197230.698494,"logger":"cmd","msg":"Version","Go Version":"go1.17.6","GOOS":"darwin","GOARCH":"arm64","helm-operator":"v1.17.0","commit":"704b02a9ba86e85f43edb1b20457859e9eedc6e6"}
{"level":"info","ts":1645197230.699863,"logger":"cmd","msg":"Watch namespaces not configured by environment variable WATCH_NAMESPACE or file. Watching all namespaces.","Namespace":""}
{"level":"info","ts":1645197231.877758,"logger":"controller-runtime.metrics","msg":"Metrics server is starting to listen","addr":":8080"}
{"level":"info","ts":1645197231.888722,"logger":"helm.controller","msg":"Watching resource","apiVersion":"tutorials.ovhcloud.com/v1","kind":"OvhNginx","namespace":"","reconcilePeriod":"1m0s"}
{"level":"info","ts":1645197231.890322,"msg":"Starting server","kind":"health probe","addr":"[::]:8081"}
{"level":"info","ts":1645197231.8903291,"msg":"Starting server","path":"/metrics","kind":"metrics","addr":"[::]:8080"}
{"level":"info","ts":1645197231.8913422,"logger":"controller.ovhnginx-controller","msg":"Starting EventSource","source":"kind source: *unstructured.Unstructured"}
{"level":"info","ts":1645197231.891497,"logger":"controller.ovhnginx-controller","msg":"Starting Controller"}
{"level":"info","ts":1645197231.993102,"logger":"controller.ovhnginx-controller","msg":"Starting workers","worker count":8}
```

And now you are ready to test it with the creation of your first CR (_tutorials_v1_ovhnginxoperator.yaml_):
```yaml
apiVersion: tutorials.ovhcloud.com/v1
kind: OvhNginx
metadata:
  name: mynginx-sample
spec:
  replicaCount: 1
  service:
    port: 80
```

Before to create the CR, create a namespace. This will be the namespace where the CR will be created and the Nginx server deployed:
```bash
❯ kubectl create ns test-ovh-nginx-operator
namespace/test-ovh-nginx-operator created

❯ kubectl get ns                           
NAME                      STATUS   AGE
default                   Active   11d
kube-node-lease           Active   11d
kube-public               Active   11d
kube-system               Active   11d
test-ovh-nginx-operator   Active   8s
```

Next create the CR:
```bash
❯ kubectl apply -f manifests/samples/tutorials_v1_ovhnginxoperator.yaml
ovhnginx.tutorials.ovhcloud.com/mynginx-sample created

❯ kubectl get ovhnginx
NAME             AGE
mynginx-sample   79s

```

What is happening in our operatoor ?
It's detecting  the new CR and is doing some things !!!
```bash
{"level":"info","ts":1645197784.822017,"logger":"controller.ovhnginx-controller","msg":"Starting EventSource","source":"kind source: *unstructured.Unstructured"}
{"level":"info","ts":1645197784.822165,"logger":"helm.controller","msg":"Watching dependent resource","ownerApiVersion":"tutorials.ovhcloud.com/v1","ownerKind":"OvhNginx","apiVersion":"apps/v1","kind":"Deployment"}
{"level":"info","ts":1645197784.82237,"logger":"controller.ovhnginx-controller","msg":"Starting EventSource","source":"kind source: *unstructured.Unstructured"}
{"level":"info","ts":1645197784.822401,"logger":"helm.controller","msg":"Watching dependent resource","ownerApiVersion":"tutorials.ovhcloud.com/v1","ownerKind":"OvhNginx","apiVersion":"v1","kind":"Service"}
{"level":"info","ts":1645197784.822422,"logger":"helm.controller","msg":"Installed release","namespace":"test-ovh-nginx-operator","name":"mynginx-sample","apiVersion":"tutorials.ovhcloud.com/v1","kind":"OvhNginx","release":"mynginx-sample"}
```

Let's  have a look in our Kubernetes cluster:
```bash
❯ kubectl get pods
NAME                                        READY   STATUS    RESTARTS   AGE
mynginx-sample-ovh-nginx-65b64c6585-wtc5g   1/1     Running   0          72s

❯ kubectl get service
NAME                       TYPE           CLUSTER-IP     EXTERNAL-IP       PORT(S)        AGE
mynginx-sample-ovh-nginx   LoadBalancer   XXX.XXX.XXX.XXX   YYY.YYY.YYY.YYY   80:30356/TCP   105s
```

Ok this seems ok but let's have a look if we visit the `http://yyy.yyy.yyy.yyy/` page:  
![Hello world from Nginx](images/hello-world.png)

You can now delete safely your CR:
```bash
❯ kubectl delete ovhnginxs.tutorials.ovhcloud.com/mynginx-sample
ovhnginx.tutorials.ovhcloud.com "mynginx-sample" deleted

❯ kubectl get pods
No resources found in test-ovh-nginx-operator namespace.

❯ kubectl get services
No resources found in test-ovh-nginx-operator namespace.
```

At this point of the tutorial your tree structure is like this:
```bash
.
├── helm-charts
│   └── ovh-nginx
│       ├── Chart.yaml
│       ├── templates
│       │   ├── _helpers.tpl
│       │   ├── deployment.yaml
│       │   └── service.yaml
│       └── values.yaml
├── manifests
│   ├── crd
│   │   └── tutorials.ovhcloud.com_ovhnginxoperators.yaml
│   └── samples
│       └── tutorials_v1_ovhnginxoperator.yaml
└── watches.yaml
```

### Deploy the operator in Kubernetes

Perhaps you think:
> ok my operator turn on my computer but how can I deploy it on my Kubernetes cluster ?

And you're right, the goal of our operator is to be independent and manage automatically all requests !

> [!info]
>
> To be more readable the following resources are simplest that the one you will have to create in the real world, specifically the security configuration.
>

It's quite simple to package and deploy our operator.
The first thing to do is to create a Dockerfile:
```dockerfile
FROM quay.io/operator-framework/helm-operator:v1.17.0

ENV HOME=/opt/helm
COPY watches.yaml ${HOME}/watches.yaml
COPY helm-charts  ${HOME}/helm-charts
WORKDIR ${HOME}
```

Build the image:
```bash
docker build -t ovhplateform/ovh-nginx-operator:1.0.0 . 
```

And push it on your prefer registry:
```bash
docker push ovhplateform/ovh-nginx-operator:1.0.0
```

The last step is to deploy your operator thanks a Kubernetes manifest (_ovh-nginx-operator.yaml_) like this one:
```yaml
# The namespace where the operator is deployed
apiVersion: v1
kind: Namespace
metadata:
  name: ovh-nginx-operator
---
# Authorisations for the operator
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRole
metadata:
  name: ovhnginxoperator-admin-role
rules:
- apiGroups:
  - tutorials.ovhcloud.com
  resources:
  - ovhnginxs
  - ovhnginxs/status
  - ovhnginxs/finalizers  
  verbs:
  - create
  - delete
  - get
  - list
  - patch
  - update
  - watch
- apiGroups:
  - ""
  resources:
  - secrets
  - "serviceaccounts"
  - "services"  
  verbs:
  - "*"
- apiGroups:
  - "apps"
  verbs:
    - "*"
  resources:
  - "deployments"
---
# The service account used for the POD where is the operator
apiVersion: v1
kind: ServiceAccount
metadata:
  name: ovh-nginx-operator-sa
  namespace: ovh-nginx-operator
---
# The affected authorisation to the service account
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: ovh-nginx-operator-admin
subjects:
- kind: ServiceAccount
  name: ovh-nginx-operator-sa
  namespace: ovh-nginx-operator
roleRef:
  kind: ClusterRole
  name: ovhnginxoperator-admin-role
  apiGroup: ""
---
# The deployment for the operator
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ovh-nginx-operator
  namespace: ovh-nginx-operator
spec:
  selector:
    matchLabels:
      app: ovh-nginx-operator
  replicas: 1 
  strategy:
    type: Recreate 
  template:
    metadata:
      labels:
        app: ovh-nginx-operator
    spec:
      serviceAccountName: ovh-nginx-operator-sa
      containers:
      - name: operator
        image: ovhplateform/ovh-nginx-operator:1.0.0
        imagePullPolicy: Always
```
And apply the file to the Kubernetes cluster:
```bash
❯ kubectl apply -f manifests/ovh-nginx-operator.yaml

❯ kubectl get pods --namespace ovh-nginx-operator
NAME                                  READY   STATUS    RESTARTS   AGE
ovh-nginx-operator-5487958499-v9q46   1/1     Running   0          70s
```

It's time to test the operator, let's play with the custom resource:
```bash
❯ kubectl apply -f manifests/samples/tutorials_v1_ovhnginxoperator.yaml
ovhnginx.tutorials.ovhcloud.com/mynginx-sample created

❯ kubectl get pods --namespace test-ovh-nginx-operator
NAME                                        READY   STATUS    RESTARTS   AGE
mynginx-sample-ovh-nginx-65b64c6585-5ddpm   1/1     Running   0          44s

❯ kubectl get services --namespace test-ovh-nginx-operator
NAME                       TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)        AGE
mynginx-sample-ovh-nginx   LoadBalancer   XXX.XXX.XXX.XXX   YYY.YYY.YYY.YYY   80:30403/TCP   2m36s
```

Update the CR like this and apply it again:
```yaml
apiVersion: tutorials.ovhcloud.com/v1
kind: OvhNginx
metadata:
  name: mynginx-sample
spec:
  replicaCount: 2
  service:
    port: 8080
```

```bash
❯ kubectl get pods --namespace test-ovh-nginx-operator
NAME                                        READY   STATUS    RESTARTS   AGE
mynginx-sample-ovh-nginx-65b64c6585-4nc88   1/1     Running   0          4m29s
mynginx-sample-ovh-nginx-65b64c6585-5ddpm   1/1     Running   0          28m

❯ kubectl get services --namespace test-ovh-nginx-operator
NAME                       TYPE           CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE
mynginx-sample-ovh-nginx   LoadBalancer   XXX.XXX.XXX.XXX   YYY.YYY.YYY.YYYY   8080:30403/TCP   30m
```

You can also play to delete the service and see that the operator recreates it !

Another tutorials on operators will be soon available to discover additional ways to develop an operator.

## Go further

Join our community of users on <https://community.ovh.com/en/>.  
The [operator](https://kubernetes.io/docs/concepts/extend-kubernetes/operator/) pattern in Kubernetes.  
The operator [SDK](https://operatorframework.io/operator-capabilities/).